fmod CELLULAR-AUTOMATA is
    sorts State State? .
    subsort State < State? .
    sorts StateLabel StateKey .
    sorts Cell Culture .
    subsort Cell < Culture .

    sort Dish .
    sort Clock .

    op _::_    : StateLabel State        -> Cell .
    op _::_->_ : StateLabel State State? -> Cell [prec 57] .

    op mt  : -> Culture [ctor] .
    op _,_ : Culture Culture -> Culture [assoc comm idem id: mt prec 60] .

    op mt   : -> State? .
    op _[_] : StateKey State      -> State? .
    op _[_] : StateKey StateLabel -> State? .
    op __   : State?   State?     -> State? [assoc comm id: mt prec 55] .

    vars N N'   : StateLabel .
    vars S S'   : State .
    vars S? S?' : State? .
    var  SK     : StateKey .
    var  C      : Culture .

    eq   N :: S -> SK[N] S?
       = N :: S -> SK[S] S? .

    eq   N :: S -> SK[N'] S? , N' :: S' -> S?'
       = N :: S -> SK[S'] S? , N' :: S' -> S?' .

    ops up down left right : -> StateKey .

    ops tick tock : -> Clock .
    op neighbors  : StateLabel -> State? .
    op _{_}       : Clock Culture -> Dish .

    eq   tick { N :: S                 , C }
       = tick { N :: S -> neighbors(N) , C } .

    eq   tock { N :: S -> S' , C }
       = tock { N :: S'      , C } .
endfm

fmod TESTING is
    extending CELLULAR-AUTOMATA .
    protecting INT .

    sort Point .
    subsort Point < StateLabel .

    op (_,_) : Int Int -> Point .
    op pt    : Int -> Point .

    vars N M : Int .

    --- 5x5 circular grid
    ops width height : -> Nat .
    eq  width  = 5 .
    eq  height = 5 .
    eq  pt(N) = (N rem width, N quo width) .

    ceq (N,M) = (N - width, M)  if N >= width .
    ceq (N,M) = (N, M - height) if M >= height .
    ceq (N,M) = (N + width, M)  if N < 0 .
    ceq (N,M) = (N, M + height) if M < 0 .

    ops X - : -> State .

    var SL : StateLabel .
    var S  : State .
    var S? : State? .

    eq neighbors((N,M)) = up[(N , M + 1)]
                          left[(N - 1 , M)]
                          down[(N , M - 1)]
                          right[(N + 1 , M)] .

    eq SL :: S -> up[X] down[X] S?    = SL :: X .
    eq SL :: S -> left[X] down[-] S?  = SL :: X .
    eq SL :: S -> left[-] right[-] S? = SL :: - [owise] .
endfm
